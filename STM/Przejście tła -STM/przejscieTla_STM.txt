#include "main.h"

unsigned short int *const LCD_FB = (unsigned short int*) 0xD0000000;   // Framebuffer
unsigned short int *const LCD_BUF = (unsigned short int*) 0xD0100000;  // Bufor graficzny
unsigned char Stan;

// Struktura kwadrat – nie jest używana w tym zadaniu
kwadrat_t __attribute__((aligned(4))) kwadrat = {.x = 120, .y = 160, .dx = 1, .dy = 1, .size = 30};

int main(void) {
	System_Init();      // Inicjalizacja systemu
	niebieskietlo();    // Zainicjuj bufor zawartością do wyświetlenia
	Clear_And_Reload_Screen();
	while (1) {
		handleGPIO();    // Obsługa przycisku
		if (Stan == 1) {
			przejscie(); // Efekt przejścia zawartości bufora
			Clear_And_Reload_Screen();
		} else {
			czerwonetlo();               // Inny stan: czerwony ekran
			Clear_And_Reload_Screen();
		}
	}
}

void czerwonetlo(void) {
	for (int i = 0; i < 320 * 240; i++) {
		LCD_BUF[i] = MAX_R << 11; // Czerwony
	}
}

void niebieskietlo(void) {
	for (int i = 0; i < 320 * 240; i++) {
		       // Niebieski
	}
}

// Procedura z efektem przejścia z bufora na ekran
void przejscie(void) {
	for (int col = 0; col < 320; col++) {
		for (int row = 0; row < 240; row++) {
			//LCD_FB[row * 320 + col] = LCD_BUF[row * 320 + col];  // Kolumna po kolumnie
			LCD_FB[row*320+col] = MAX_B<<1;
		}
		for (volatile int d = 0; d < 1000000; d++);  // Krótka pauza dla efektu
	}
}

// Kopiowanie bufora do framebuffer-a (pełne od razu)
void Clear_And_Reload_Screen(void) {
	for (int i = 0; i < 320 * 240; i++) {
		LCD_FB[i] = LCD_BUF[i];
		LCD_BUF[i] = 0;
	}
}

// Obsługa GPIO i przycisku
void handleGPIO(void) {
	if (!(GPIOA->IDR & 1))   // Przycisk nie wciśnięty
		Stan = 0;
	else
		Stan = 1;            // Wciśnięty
}

// Inicjalizacja systemu
void System_Init(void) {
	HAL_Init();
	SystemClock_Config();
	BSP_SDRAM_Init();
	BSP_LCD_Init();

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN;       // Dioda LED
	GPIOG->MODER |= GPIO_Mode_OUT << (14 * 2);
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;       // Przycisk
}

// Obsługa przerwania SysTick (dla HAL)
void SysTick_Handler(void) {
	HAL_IncTick();
}

-------------------------
main.h

#include <stdint.h>
#include "stm32f429xx.h"
#include "stm32f4xx_gpio.h"
#include <stdlib.h>

//Wymiary wyświetlacza
#define LCD_WIDTH 320U
#define LCD_HEIGHT 240U
#define LCD_LAST_X 318U
#define LCD_LAST_Y 239U

//Maksymalne składowe komponentów RGB
#define MAX_R 31U
#define MAX_G 63U
#define MAX_B 31U

//Definicja struktury kwadrat z polami "upakowanymi" i wyrównanymi do 4-ech bajtów
typedef   struct {
	unsigned int x, y , size;
	int  dx , dy;
} __attribute__((packed,aligned(4))) kwadrat_t ;

#define ABS(x) ((unsigned int)(x>=0?x:-x))

typedef enum
{
  CENTER_MODE             = 0x01,    /* center mode */
  RIGHT_MODE              = 0x02,    /* right mode  */
  LEFT_MODE               = 0x03,    /* left mode   */
}Text_AlignModeTypdef;
typedef enum
{
  HAL_OK       = 0x00U,
  HAL_ERROR    = 0x01U,
  HAL_BUSY     = 0x02U,
  HAL_TIMEOUT  = 0x03U
} HAL_StatusTypeDef;

void System_Init(void);
HAL_StatusTypeDef HAL_Init(void);
void SystemClock_Config(void);
void handleGPIO(void);
void Clear_And_Reload_Screen(void);
void move_square_C(void);
void drawGradient(void);
void printText(void);
void BSP_SDRAM_Init(void);
void BSP_LCD_Init(void);
void BSP_LCD_DisplayStringAt(uint16_t X, uint16_t Y, uint8_t *pText, Text_AlignModeTypdef mode);
void BSP_LCD_DisplayRot90StringAt(uint16_t X, uint16_t Y, uint8_t *pText, Text_AlignModeTypdef mode);

void move_square_asm(void);
void kopiuj_blok_pamieci(unsigned short int* FROM,unsigned short int* INTO,int SIZE);
void kasuj_blok_pamieci(unsigned short int* WHERE,int SIZE);
unsigned short int RGB16Pack(unsigned int B,unsigned int G,unsigned int R);
void fillMemory(void* adres_bazowy, unsigned long rozmiar,unsigned short int wartosc);
void SysTick_Handler(void);
void HAL_IncTick(void);
void czerwonetlo(void);
void niebieskietlo(void);
void przejscie(void);
